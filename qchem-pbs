#!/usr/bin/env python3

# qchem-pbs can replace omniqchem.csh and node_local_qchem.csh on
# venus, diabatical, and helium. Pass -h for help; contact
# valecs@sas.upenn.edu if something seems broken.


import os, subprocess
from pathlib import Path
from socket import gethostname
from collections import defaultdict
import argparse
import time


ncpus = defaultdict(lambda: 48,
                    {'venus': 48,
                     'diabatical': 32,
                     'helium': 32,  # FIXME: is this correct?
                     }
                    )


def host():
    return gethostname().split('.')[0]


def getArgs():
    parser = argparse.ArgumentParser(description='Execute Q-Chem on a node via PBS; MPI jobs not supported')
    parser.add_argument("--input", "-i", metavar="INPUT", required=True, type=Path,
                        help="Q-Chem input file")
    parser.add_argument("--output", "-o", metavar="OUTPUT", type=Path,
                        help="Q-Chem output file; determined automatically if omitted")
    parser.add_argument("--threads", "-t", metavar="THREADS", default=4, type=int,
                        help="Number of OpenMP threads to use; defaults to 4")
    parser.add_argument("-mem", "-m", metavar="MEMORY", default=8192, type=int,
                        help="Max memory in MB; defaults to 8192")
    parser.add_argument("--branch", "-b", metavar="BRANCH", type=Path,
                        help="Full path to Q-Chem branch; if $QCRT is set, may simply be name of branch below $QCRT")
    parser.add_argument("--in-dir", metavar="DIR", type=Path,
                        help="Path to input directory for restartable jobs")
    parser.add_argument("--out-dir", metavar="DIR", default="./run",
                        type=Path, help="Path to output files; defaults to ./run")
    # parser.add_argument("--wall", "-w", metavar="WALL", default="160:00:00", help="max wall-clock time, HH:MM:SS")
    parser.add_argument("--dry-run", "-n", default=False, action='store_true',
                        help="Don't acutally launch the job; just verify settings")

    return parser.parse_args()


def env(key, value=None):
    """Returns or sets an environmental variable"""
    if value is None:
        if key in os.environ.keys():
            return os.environ[key]
        else:
            return ""
    else:
        os.environ[key] = str(value)


def isValidQC(path):
    """Determines if the path is a valid Q-Chem install"""
    return (Path(path) / "exe/qcprog.exe").exists()


def validate(args):
    """Validates CLI args and environmental variables, setting the latter as necessary"""
    invalid = 0

    if not args.input.is_file():
        invalid += 1
        print("Input file", args.input, "is not a file!")

    # FIXME: check input file for rem & molecule sections

    if args.output is None:
        args.output = args.input.with_suffix(".out")

    if args.output.exists():
        invalid += 1
        print("Output file", args.output, "already exists!")

    tmax = ncpus[host()]
    if args.threads < 1 or args.threads > tmax:
        invalid += 1
        print("Must have at least 1 thread and no more than", tmax, "on", host(),"!")
    else:
        env("QCTHREADS", args.threads)

    if args.mem <= 0:
        invalid += 1
        print("Memory requested must be finite!")

    if args.in_dir is not None and not args.in_dir.is_dir():
        invalid += 1
        print("Input directory", args.in_dir, "is not a directory!")

    if args.branch is not None:
        if isValidQC(args.branch):
            env("QC", args.branch)
        elif isValidQC(env("QCRT") / args.branch):
            args.branch = env("QCRT") / args.branch
            env("QC", args.branch)
        else:
            print("branch", args.branch, "cannot be found and/or $QCRT not set!")
            invalid += 1

    if not isValidQC(env("QC")):
        invalid += 1
        print("Valid Q-Chem install not found at $QC!")

    # FIXME: allow setting QCSCRATCH from CLI
    args.qcscratch = Path(env("QCSCRATCH"))
    if not args.qcscratch.is_absolute():
        invalid += 1
        print("$QCSCRATCH must be an absolute path!")

    for var in ["QC_EXT_LIBS", "QCAUX"]:
        if not Path(env(var)).is_absolute() or Path(env(var)).exists():
            invalid += 1
            print("Q-Chem requires that the variable", var, "be set and exist!")

    if env("QCPLATFORM") is "":
        invalid += 1
        print("Q-Chem requires that the variable", "QCPLATFORM", "be set!")

    return invalid


def getScript(args):
    script = []

    name = args.input.stem
    scratch = args.qcscratch / Path(name).with_suffix("." + str(time.time()))
    temp    = args.qcscratch / Path(name).with_suffix("." + str(time.time() % 10))

    script.append(f'mkdir -p {scratch}')

    if args.in_dir is not None:
        script.append(f'cp -a "{args.in_dir.absolute()}" "{temp}"')
        script.append(f'mv -T "{temp}" "{scratch}"')

    script.append(f'cd "{scratch}"')

    script.append(f'$QC/exe/qcprog.exe "{args.input.absolute()}" "{scratch}"')
    script.append(f'mv -T "{scratch}" "{args.out_dir.absolute()}"')

    # return "\n".join(script)
    return b"\n".join(map(lambda s: bytes(s, encoding="ascii"), script))


def main():
    args = getArgs()
    invalid = validate(args)  # sets $QCTHREADS & $QC, guarantees $QCSCRATCH exists

    if invalid > 0:
        print(invalid, "invalid option(s); cannot proceed")
        exit(-1)
    else:
        print("Finished checking input; no errors.")

    if args.dry_run:
        exit(0)

    args.out_dir.mkdir(parents=True, exist_ok=True)

    # FIXME: should we have a way to choose between the inplace and copying script?
    script = b"$QC/exe/qcprog.exe " + bytes(args.input.absolute()) + b" " + bytes(args.out_dir.absolute()) + b"\n"
    # FIXME: should we use the qchem script?
    script = getScript(args)

    qsub = ["qsub", "-V", "-j", "oe",
            "-o", str(args.output.absolute()),
            "-N", str(args.input.stem),
            "-l", "nodes=1:ppn=" + str(args.threads),
            "-l", "mem=" + str(args.mem) + "mb",
            # FIXME: include walltime
            # "-l", "walltime=" + str(args.wall),
            ]

    subprocess.run(qsub, input=script)


if __name__ == "__main__":
    main()
