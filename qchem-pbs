#!/usr/bin/env python3

# qchem-pbs can replace omniqchem.csh and node_local_qchem.csh on
# venus, diabatical, and helium. Pass -h for help; contact
# valecs@sas.upenn.edu if something seems broken.


import os, subprocess
from pathlib import Path
from socket import gethostname
from collections import defaultdict
import argparse
import time


ncpus = defaultdict(lambda: print("Warning: unknown cluster---thread limit may be unreliable!") or 1024,
                    {'venus': 48,
                     'diabatical': 32,
                     'helium': 32,  # FIXME: is this correct?
                     }
                    )


def host():
    return gethostname().split('.')[0]


def getArgs():
    parser = argparse.ArgumentParser(description='Execute Q-Chem on a node via PBS; MPI jobs not supported')
    parser.add_argument("input", metavar="QCINPUT", type=Path, help="Q-Chem input file")
    parser.add_argument("--dry-run", "-n", default=False, action='store_true',
                        help="Don't acutally launch the job; just verify parameters")

    parser.add_argument("--output", "-o", metavar="OUTPUT", type=Path,
                        help="Q-Chem output file; determined automatically from input if omitted")
    parser.add_argument("--threads", "-t", metavar="THREADS", default=4, type=int,
                        help="Number of OpenMP threads to use; defaults to 4")
    parser.add_argument("--mem", "-m", metavar="MEMORY", default=8192, type=int,
                        help="Max memory in MB; defaults to 8192")
    parser.add_argument("--branch", "-b", metavar="BRANCH", type=Path,
                        help="Full path to Q-Chem branch; if $QCRT is set, may simply be name of branch below $QCRT")
    parser.add_argument("--save", default=False, action='store_true', help="save scratch files to ODIR/scratch")
    parser.add_argument("--outdir", metavar="ODIR", default="./run",
                        type=Path, help="Path to output scratch files; defaults to ./run")
    parser.add_argument("--indir", metavar="IDIR", type=Path,
                        help="Path to input directory for restartable jobs (ODIR from a previous job)")
    parser.add_argument("--wall", "-w", metavar="WALL", default=120, type=float, help="max wall-clock time in hours")

    return parser.parse_args()


def env(key, value=None):
    """Returns or sets an environmental variable"""
    if value is None:
        if key in os.environ.keys():
            return os.environ[key]
        else:
            return ""
    else:
        os.environ[key] = str(value)


def isValidQC(path):
    """Determines if the path is a valid Q-Chem install"""
    return (Path(path) / "exe/qcprog.exe").exists()


def validate(args):
    """Validates CLI args and environmental variables, setting the latter as necessary"""
    invalid = 0

    if not args.input.is_file():
        invalid += 1
        print("Input file", args.input, "is not a file!")

    if args.output is None:
        args.output = args.input.with_suffix(".out")

    if args.output.exists():
        invalid += 1
        print("Output file", args.output, "already exists!")

    tmax = ncpus[host()]
    if args.threads < 1 or args.threads > tmax:
        invalid += 1
        print("Must have at least 1 thread and no more than", tmax, "on", host(),"!")
    else:
        env("QCTHREADS", args.threads)
        
    if args.wall <= 0:
        invalid += 1
        print("Wall-clock time must be finite!")

        
    if args.mem <= 0:
        invalid += 1
        print("Memory requested must be finite!")

    if args.indir is not None and not args.indir.is_dir():
        invalid += 1
        print("Input directory", args.indir, "is not a directory!")

    if args.outdir.is_absolute():
        invalid +=1
        printf("The argument to --outdir must be a relative path!")

    if args.branch is not None:
        if isValidQC(args.branch):
            env("QC", args.branch)
        elif isValidQC(env("QCRT") / args.branch):
            args.branch = env("QCRT") / args.branch
            env("QC", args.branch)
        else:
            print("branch", args.branch, "cannot be found and/or $QCRT not set!")
            invalid += 1

    if not isValidQC(env("QC")):
        invalid += 1
        print("Valid Q-Chem install not found at $QC!")

    args.qcscratch = Path(env("QCSCRATCH"))
    if not args.qcscratch.is_absolute():
        invalid += 1
        print("$QCSCRATCH must be an absolute path!")

    for var in ["QC_EXT_LIBS", "QCAUX"]:
        if not Path(env(var)).is_absolute() or not Path(env(var)).exists():
            invalid += 1
            print("Q-Chem requires that the variable", var, "be set and exist!")

    if env("QCPLATFORM") == "":
        invalid += 1
        print("Q-Chem requires that the variable", "QCPLATFORM", "be set!")

    return invalid


def getScript(args):
    """This function works by building up a list of shell (or pbs)
    statements and then joining them all together in a bytestream"""

    script = []

    name = args.input.stem
    scratch = args.qcscratch / Path(name).with_suffix("." + str(time.time()))
    # temp    = args.qcscratch / Path(name).with_suffix("." + str(time.time() % 10))    
    script.append('#!/bin/sh')
    script.append('echo job starts at $(date)')
    script.append('echo')
    script.append(f'mkdir -p {scratch / args.outdir}')

    if args.indir is not None:
        # script.append(f'cp -a "{args.indir.absolute()}" "{temp}"')
        # script.append(f'mv -T "{temp}" "{scratch / args.outdir}"')
        # trailing slash required to copy contents
        script.append(f'rsync -ar "{args.indir.absolute()}/." "{scratch / args.outdir}"')

    script.append(f'cd "{scratch}"')

    script.append(f'$QC/exe/qcprog.exe "{args.input.absolute()}" "{scratch / args.outdir}"')
    if not args.save:
        script.append(f"rm -rf {args.outdir}")
        
    # trailing slash required to copy contents from scratch
    script.append(f'rsync -ar "{scratch}/." "{args.cwd}"')
    script.append('echo')
    script.append('echo job completes at $(date)')
    
    return b"\n".join(map(lambda s: bytes(s, encoding="ascii"), script))


def main():
    args = getArgs()
    invalid = validate(args)  # validates & sets $QCTHREADS, $QC, etc...
    args.cwd=Path(".").absolute()

    if invalid > 0:
        print(invalid, "invalid option(s); cannot proceed")
        exit(-1)
    else:
        print("Finished checking input.")

    if args.dry_run:
        exit(0)

    if args.save:
        args.outdir.mkdir(parents=True, exist_ok=True)

    # FIXME: Use the qchem script to support multi-job files with @@@
    script = getScript(args)

    qsub = ["qsub", "-V", "-j", "oe",
            "-o", str(args.output.absolute()),
            "-N", str(args.input.stem),
            "-l", "nodes=1:ppn=" + str(args.threads),
            "-l", "mem=" + str(args.mem) + "mb",
            "-l", "walltime=" + str(args.wall*3600),
            ]

    subprocess.run(qsub, input=script)


if __name__ == "__main__":
    main()
